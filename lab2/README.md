# 实验报告
PB21111639 李牧龙

### 运行说明：
1. 该shell基于助教提供的框架编写（可能以及被魔改到看不出来了），Makefile即为助教提供的Makefile。将shell.cpp和Makefile放置在同一个路径下，即可用make编译，make clean清除编译。
2. 由于只实现了后台命令和wait命令，未实现前后台切换，因此无法中止后台命令的运行。请不要尝试类似
`ping baidu.com &`的命令。

### 可能与bash不同：
1. 使用 & 将命令挂在后台时，shell不会通过控制台输出，但管道和重定向仍然有效。这是因为shell不会wait后台命令，通过控制台输入可能会导致命令提示符与输出错位，或输出影响输入。
2. 支持同时对输入和输出进行重定向，但当同时有多个输入重定向或多个输出重定向时，只有最后一个有效。
3. history功能记录的历史命令保存在内存中，因此当shell被关闭后就会清空。
4. 基于助教提供的框架，命令是按空格分割的，因此不会识别由双引号标识的字符串。

### 加分项：
1. cd不带参数时可以返回家目录
2. 支持history
3. 支持Ctrl D退出shell
4. 支持`echo ~<user>`打印对应用户的家目录

### 实现思路：
1. 基于助教的框架，shell通过一个while循环来循环读入命令和执行。执行命令时，无论是什么命令/命令有多少条，均fork()产生一个子进程（下称子进程0）。
2. 子进程0将自己设为一个单独的前台进程组（或分离会话组在后台运行），将命令按管道格式拆分，根据需要构建管道，随后循环fork()出1个或多个子进程来执行每一条命令。在这些子进程0生成的子进程中会根据需要进行重定向等操作，若为内建命令则直接返回（由shell父进程执行）。子进程0循环wait所有子进程结束。
3. 父进程根据需要（是否后台执行）waitpid等待子进程0，随后扫描输入的命令中的内建命令并执行（尽管实验不要求考虑含有内建命令的管道和重定向，但实际上这样的内建命令也可以被执行，只是管道和重定向不会生效）。

### 一些实现细节：
1. 助教提供的框架中命令提示符仅为"# "，本人将其修改为了"工作区路径 $ "（即类似原版bash）。
2. 拆分命令时，不依赖管道和重定向符号两端的空格。因此管道和重定向符号两边没有空格也可以正常运行。